# Phase 7: Search & Undo System

## Overview
**Duration**: Week 7  
**Goal**: Implement PostgreSQL full-text search with highlighting and complete the undo system with Redis-backed token storage.

## Prerequisites
- Phases 1-6 completed
- Redis configured and working
- Database search_vector trigger created

---

## Core Design Decisions

### Search Filter Combination Order
```
FTS AND FILTER COMBINATION RULE:

When combining full-text search with other filters, the processing order is:

1. FTS filtering MUST apply FIRST
   - Narrow to documents matching the search query
   - This leverages the GIN index efficiently

2. Standard filters narrow the result set
   - status, project_id, tags, priority, date ranges
   - Applied as additional WHERE clauses

3. Ordering by FTS rank
   - Results ordered by ts_rank() relevance
   - Additional sort fields can be secondary

RATIONALE:
- FTS with GIN index is most selective
- Applying FTS first prevents full table scans
- Filters on indexed columns further reduce results
- Rank ordering makes results useful

EXAMPLE:
SELECT * FROM tasks
WHERE search_vector @@ plainto_tsquery('english', 'meeting')  -- FTS first
  AND user_id = :userId                                        -- Always required
  AND project_id = 5                                           -- Additional filter
  AND status = 'pending'                                       -- Additional filter
ORDER BY ts_rank(search_vector, plainto_tsquery('english', 'meeting')) DESC
LIMIT 20;
```

### Search Performance Requirements
```
SEARCH ENDPOINT PERFORMANCE:

The search endpoint should be lightweight enough to handle 
multiple requests per second per user (for typeahead/autocomplete).

Target performance:
- < 50ms for simple queries
- < 100ms for filtered queries
- < 200ms for complex multi-type searches

Achieved through:
- GIN index on search_vector
- Debounced frontend requests (300ms)
- Efficient query construction
- Pagination limiting result size
```

### Undo Previous State Definition
```
UNDO PREVIOUS STATE FIELDS:

When storing previous state for undo operations, include these fields:

TASK UPDATE UNDO - Include:
- id (for lookup)
- title
- description
- status
- project_id
- priority
- due_date
- due_time
- tags (array of tag IDs)
- is_recurring
- recurrence_rule
- recurrence_type
- recurrence_end_date

TASK UPDATE UNDO - Exclude (auto-regenerated):
- search_vector (regenerated by trigger)
- updated_at (set on save)

TASK DELETE UNDO - Include ALL fields:
- All fields from update plus:
- created_at
- completed_at
- original_task_id
- position

PROJECT ARCHIVE UNDO - Include:
- id
- is_archived (previous value: false)
```

---

## Sub-Phase 7.1: PostgreSQL Full-Text Search Setup

### Objective
Configure and optimize PostgreSQL full-text search for tasks.

### Tasks

- [ ] **7.1.1** Verify search_vector column and trigger
  ```sql
  -- Verify trigger exists
  SELECT tgname, tgenabled 
  FROM pg_trigger 
  WHERE tgname = 'tasks_search_vector_update';
  
  -- Verify search_vector is populated
  SELECT id, title, search_vector 
  FROM tasks 
  LIMIT 5;
  ```

- [ ] **7.1.2** Create migration to populate existing data
  ```sql
  -- Migration: Update existing tasks search_vector
  UPDATE tasks 
  SET search_vector = to_tsvector('english', 
      COALESCE(title, '') || ' ' || COALESCE(description, '')
  );
  ```

- [ ] **7.1.3** Create GIN index for search
  ```sql
  CREATE INDEX idx_tasks_search_gin 
  ON tasks 
  USING GIN (search_vector);
  ```

- [ ] **7.1.4** Test search performance
  ```sql
  EXPLAIN ANALYZE
  SELECT id, title, ts_rank(search_vector, query) as rank
  FROM tasks, plainto_tsquery('english', 'meeting') query
  WHERE search_vector @@ query
  ORDER BY rank DESC
  LIMIT 20;
  ```

### Completion Criteria
- [ ] Trigger populates search_vector
- [ ] GIN index created
- [ ] Existing data indexed
- [ ] Query performance < 100ms

### Files to Create
```
migrations/VersionXXX_PopulateSearchVector.php
migrations/VersionXXX_CreateSearchIndex.php
```

---

## Sub-Phase 7.2: Search Repository Methods

### Objective
Create repository methods for full-text search queries.

### Tasks

- [ ] **7.2.1** Create basic search method with ResultSetMapping
  ```php
  // src/Repository/TaskRepository.php
  
  use Doctrine\ORM\Query\ResultSetMapping;
  
  public function search(User $user, string $query, int $limit = 20, int $offset = 0): array
  {
      $sql = "
          SELECT t.*, ts_rank(t.search_vector, q) as rank
          FROM tasks t, plainto_tsquery('english', :query) q
          WHERE t.user_id = :userId
            AND t.search_vector @@ q
          ORDER BY rank DESC
          LIMIT :limit OFFSET :offset
      ";
      
      // Define ResultSetMapping to map native query results to Task entity
      $rsm = new ResultSetMapping();
      $rsm->addEntityResult(Task::class, 't');
      $rsm->addFieldResult('t', 'id', 'id');
      $rsm->addFieldResult('t', 'title', 'title');
      $rsm->addFieldResult('t', 'description', 'description');
      $rsm->addFieldResult('t', 'status', 'status');
      $rsm->addFieldResult('t', 'priority', 'priority');
      $rsm->addFieldResult('t', 'due_date', 'dueDate');
      $rsm->addFieldResult('t', 'due_time', 'dueTime');
      $rsm->addFieldResult('t', 'created_at', 'createdAt');
      $rsm->addFieldResult('t', 'updated_at', 'updatedAt');
      $rsm->addFieldResult('t', 'completed_at', 'completedAt');
      $rsm->addFieldResult('t', 'project_id', 'project');
      $rsm->addFieldResult('t', 'user_id', 'user');
      $rsm->addScalarResult('rank', 'rank');
      
      return $this->getEntityManager()
          ->createNativeQuery($sql, $rsm)
          ->setParameter('query', $query)
          ->setParameter('userId', $user->getId())
          ->setParameter('limit', $limit)
          ->setParameter('offset', $offset)
          ->getResult();
  }
  ```

- [ ] **7.2.2** Implement search with filters (FTS-first approach)
  ```php
  /**
   * Search with filters following the FTS-first rule:
   * 1. FTS filtering applies first (leverages GIN index)
   * 2. Standard filters narrow the result set
   * 3. Results ordered by rank
   */
  public function searchWithFilters(
      User $user, 
      string $query, 
      TaskFilterCriteria $filters
  ): array
  {
      // Start with FTS as the primary filter
      $sql = "
          SELECT t.*, ts_rank(t.search_vector, plainto_tsquery('english', :query)) as rank
          FROM tasks t
          WHERE t.user_id = :userId
            AND t.search_vector @@ plainto_tsquery('english', :query)
      ";
      
      $params = [
          'query' => $query,
          'userId' => $user->getId()
      ];
      
      // Apply additional filters (narrow the FTS result set)
      if ($filters->getStatus()) {
          $sql .= " AND t.status = :status";
          $params['status'] = $filters->getStatus();
      }
      
      if ($filters->getProjectId()) {
          $sql .= " AND t.project_id = :projectId";
          $params['projectId'] = $filters->getProjectId();
      }
      
      if ($filters->getPriorityMin() !== null) {
          $sql .= " AND t.priority >= :priorityMin";
          $params['priorityMin'] = $filters->getPriorityMin();
      }
      
      // Add more filter conditions...
      
      // Order by FTS rank
      $sql .= " ORDER BY rank DESC";
      $sql .= " LIMIT :limit OFFSET :offset";
      
      // ... execute query
  }
  ```

- [ ] **7.2.3** Implement highlight generation
  ```php
  public function searchWithHighlights(User $user, string $query): array
  {
      $sql = "
          SELECT t.*,
              ts_headline('english', t.title, q, 
                  'StartSel=<mark>, StopSel=</mark>, MaxWords=50') as title_highlight,
              ts_headline('english', COALESCE(t.description, ''), q,
                  'StartSel=<mark>, StopSel=</mark>, MaxWords=100') as description_highlight,
              ts_rank(t.search_vector, q) as rank
          FROM tasks t, plainto_tsquery('english', :query) q
          WHERE t.search_vector @@ q AND t.user_id = :userId
          ORDER BY rank DESC
      ";
      
      // ... execute with RSM including scalar results for highlights
  }
  ```

- [ ] **7.2.4** Implement prefix search for autocomplete (extended)
  ```php
  /**
   * Prefix search for autocomplete suggestions.
   * Searches across tasks, projects, and tags.
   */
  public function prefixSearch(User $user, string $prefix): array
  {
      $results = [
          'tasks' => [],
          'projects' => [],
          'tags' => []
      ];
      
      // Search task titles
      $taskSql = "
          SELECT DISTINCT title, id
          FROM tasks
          WHERE user_id = :userId
            AND title ILIKE :prefix || '%'
          ORDER BY title
          LIMIT 5
      ";
      $results['tasks'] = $this->executeQuery($taskSql, $user, $prefix);
      
      // Search project names
      $projectSql = "
          SELECT DISTINCT name, id
          FROM projects
          WHERE user_id = :userId
            AND name ILIKE :prefix || '%'
          ORDER BY name
          LIMIT 5
      ";
      $results['projects'] = $this->executeQuery($projectSql, $user, $prefix);
      
      // Search tag names
      $tagSql = "
          SELECT DISTINCT t.name, t.id
          FROM tags t
          JOIN task_tags tt ON t.id = tt.tag_id
          JOIN tasks ta ON tt.task_id = ta.id
          WHERE ta.user_id = :userId
            AND t.name ILIKE :prefix || '%'
          ORDER BY t.name
          LIMIT 5
      ";
      $results['tags'] = $this->executeQuery($tagSql, $user, $prefix);
      
      return $results;
  }
  ```

- [ ] **7.2.5** Implement advanced search operators (optional enhancement)
  ```php
  /**
   * Parse advanced search syntax and convert to tsquery.
   * 
   * Supported operators:
   * - Phrase search: "meeting notes" → 'meeting' <-> 'notes'
   * - Prefix search: meet* → 'meet':*
   * - Negation: -cancelled → !'cancelled'
   * - OR: meeting OR call → 'meeting' | 'call'
   * 
   * Falls back to plainto_tsquery for simple queries.
   */
  public function parseAdvancedQuery(string $input): string
  {
      // Check for advanced operators
      if (!preg_match('/["\-*]|\bOR\b/', $input)) {
          // Simple query, use plainto_tsquery
          return "plainto_tsquery('english', " . $this->quote($input) . ")";
      }
      
      // Parse advanced syntax
      $tsquery = $this->convertToTsquery($input);
      return "to_tsquery('english', " . $this->quote($tsquery) . ")";
  }
  
  private function convertToTsquery(string $input): string
  {
      // Handle phrases: "meeting notes" → 'meeting' <-> 'notes'
      $input = preg_replace_callback('/"([^"]+)"/', function($m) {
          $words = explode(' ', trim($m[1]));
          return implode(' <-> ', array_map(fn($w) => "'$w'", $words));
      }, $input);
      
      // Handle prefix: meet* → 'meet':*
      $input = preg_replace('/(\w+)\*/', "'$1':*", $input);
      
      // Handle negation: -word → !'word'
      $input = preg_replace('/\-(\w+)/', "!'$1'", $input);
      
      // Handle OR
      $input = preg_replace('/\bOR\b/', '|', $input);
      
      // Remaining words get ANDed
      $input = preg_replace('/\s+/', ' & ', trim($input));
      
      return $input;
  }
  ```

### Completion Criteria
- [ ] Basic search returns ranked results
- [ ] ResultSetMapping properly defined
- [ ] Filters combinable with search (FTS-first)
- [ ] Highlights generated correctly
- [ ] Prefix search for autocomplete works (tasks, projects, tags)

### Files to Update
```
src/Repository/TaskRepository.php
src/Repository/ProjectRepository.php
```

---

## Sub-Phase 7.3: Search API Endpoint

### Objective
Create the search API endpoint with comprehensive features.

### Tasks

- [ ] **7.3.1** Create search endpoint
  ```php
  GET /api/v1/search?q={query}
  
  Query params:
  - q: string (required, search query, min 2 chars)
  - type: 'all'|'tasks'|'projects' (default: all)
  - status: string (filter)
  - project_id: int (filter)
  - tag: string (filter)
  - include_completed: bool (default: false)
  - highlight: bool (default: true)
  - page: int
  - per_page: int
  ```

- [ ] **7.3.2** Implement SearchService
  ```php
  // src/Service/SearchService.php
  
  public function search(User $user, SearchCriteria $criteria): SearchResult
  {
      $startTime = microtime(true);
      
      $results = [
          'tasks' => [],
          'projects' => []
      ];
      
      if ($criteria->includesTasks()) {
          $results['tasks'] = $this->searchTasks($user, $criteria);
      }
      
      if ($criteria->includesProjects()) {
          $results['projects'] = $this->searchProjects($user, $criteria);
      }
      
      $searchTimeMs = (microtime(true) - $startTime) * 1000;
      
      return new SearchResult($results, $searchTimeMs);
  }
  ```

- [ ] **7.3.3** Define search response format
  ```php
  Response:
  {
    "data": {
      "tasks": [
        {
          "id": 123,
          "title": "Review <mark>meeting</mark> notes",
          "title_raw": "Review meeting notes",
          "description_highlight": "...prepare for <mark>meeting</mark>...",
          "rank": 0.95,
          "project": { "id": 5, "name": "Work" }
        }
      ],
      "projects": [
        {
          "id": 5,
          "name": "Work <mark>Meeting</mark>s",
          "rank": 0.80
        }
      ]
    },
    "meta": {
      "query": "meeting",
      "task_count": 5,
      "project_count": 1,
      "total": 6,
      "search_time_ms": 15
    }
  }
  ```

- [ ] **7.3.4** Handle empty/invalid queries
  ```php
  // Empty query
  {
    "error": {
      "code": "VALIDATION_ERROR",
      "message": "Search query required",
      "details": { "q": ["This field is required"] }
    }
  }
  
  // Query too short
  {
    "error": {
      "code": "VALIDATION_ERROR", 
      "message": "Search query too short",
      "details": { "q": ["Minimum 2 characters required"] }
    }
  }
  ```

- [ ] **7.3.5** Document future search scope (Phase 8+)
  ```php
  /**
   * FUTURE: Search scope expansion (Phase 8+)
   * 
   * When subtasks and comments are added, consider including them in search:
   * - Subtask titles: Add to task's search_vector or search separately
   * - Comments: Add comment content to searchable scope
   * 
   * Decision needed:
   * - Option A: Expand task search_vector to include subtask titles
   * - Option B: Separate subtask search endpoint
   * - Option C: Include in global search with type filter
   */
  ```

### Completion Criteria
- [ ] Search endpoint returns results
- [ ] Highlights included when requested
- [ ] Filters work with search
- [ ] Both tasks and projects searchable
- [ ] Performance metrics included

### Files to Create
```
src/Controller/Api/SearchController.php
src/Service/SearchService.php
src/DTO/SearchCriteria.php
src/DTO/SearchResult.php
```

---

## Sub-Phase 7.4: Task Filter Search Integration

### Objective
Add search capability to the main task list endpoint.

### Tasks

- [ ] **7.4.1** Add search parameter to task list
  ```php
  GET /api/v1/tasks?search={query}&status=pending&project_id=5
  
  // Combines FTS with all other filters
  // FTS applies first, then other filters narrow results
  ```

- [ ] **7.4.2** Update TaskRepository.findByFilters()
  ```php
  public function findByFilters(User $user, TaskFilterCriteria $criteria): array
  {
      $qb = $this->createQueryBuilder('t')
          ->where('t.user = :user')
          ->setParameter('user', $user);
      
      // If search query provided, use PostgreSQL FTS
      // NOTE: FTS filter applies FIRST (most selective, uses GIN index)
      if ($criteria->hasSearch()) {
          $this->applySearchFilter($qb, $criteria->getSearch());
      }
      
      // Apply other filters (narrow the FTS result set)
      $this->applyFilters($qb, $criteria);
      
      return $qb->getQuery()->getResult();
  }
  
  /**
   * Apply PostgreSQL full-text search filter.
   * Uses @@ operator and plainto_tsquery (NOT MySQL MATCH AGAINST).
   */
  private function applySearchFilter(QueryBuilder $qb, string $query): void
  {
      // PostgreSQL FTS syntax - NOT MySQL MATCH AGAINST
      $qb->andWhere("t.search_vector @@ plainto_tsquery('english', :searchQuery)")
         ->setParameter('searchQuery', $query)
         ->addOrderBy("ts_rank(t.search_vector, plainto_tsquery('english', :searchQuery))", "DESC");
  }
  ```

- [ ] **7.4.3** Verify combined filter performance
  ```sql
  -- Verify query plan uses GIN index
  EXPLAIN ANALYZE
  SELECT * FROM tasks
  WHERE user_id = 1
    AND search_vector @@ plainto_tsquery('english', 'meeting')
    AND project_id = 5
    AND status = 'pending'
  ORDER BY ts_rank(search_vector, plainto_tsquery('english', 'meeting')) DESC;
  
  -- Expected: Index Scan using idx_tasks_search_gin
  ```

### Completion Criteria
- [ ] Search parameter works on /api/v1/tasks
- [ ] Uses PostgreSQL @@ operator (not MySQL MATCH AGAINST)
- [ ] Combines correctly with filters (FTS-first)
- [ ] Results still ranked by relevance
- [ ] Performance acceptable (<100ms)

### Files to Update
```
src/Repository/TaskRepository.php
src/Service/Filter/TaskFilterBuilder.php
```

---

## Sub-Phase 7.5: Search UI Implementation

### Objective
Create the frontend search interface.

### Tasks

- [ ] **7.5.1** Create search input component
  ```twig
  {# templates/components/search-input.html.twig #}
  
  <div class="search-container">
    <input type="text" 
           id="global-search" 
           placeholder="Search tasks..."
           autocomplete="off">
    <div id="search-results" class="search-dropdown hidden"></div>
  </div>
  ```

- [ ] **7.5.2** Implement search JavaScript with all helper functions
  ```javascript
  // assets/js/search.js
  
  class SearchManager {
      constructor() {
          this.searchInput = document.getElementById('global-search');
          this.resultsContainer = document.getElementById('search-results');
          this.debounceTimer = null;
          this.selectedIndex = -1;
          
          this.init();
      }
      
      init() {
          this.searchInput.addEventListener('input', (e) => this.handleInput(e));
          this.searchInput.addEventListener('keydown', (e) => this.handleKeydown(e));
          document.addEventListener('click', (e) => this.handleClickOutside(e));
          
          // Global shortcut: / to focus search
          document.addEventListener('keydown', (e) => {
              if (e.key === '/' && !this.isInputFocused()) {
                  e.preventDefault();
                  this.searchInput.focus();
              }
          });
      }
      
      handleInput(e) {
          clearTimeout(this.debounceTimer);
          this.debounceTimer = setTimeout(() => {
              this.performSearch(e.target.value);
          }, 300); // 300ms debounce for performance
      }
      
      async performSearch(query) {
          if (query.length < 2) {
              this.hideResults();
              return;
          }
          
          try {
              const response = await fetch(
                  `/api/v1/search?q=${encodeURIComponent(query)}`,
                  { headers: { 'Authorization': `Bearer ${getToken()}` } }
              );
              const data = await response.json();
              this.displayResults(data);
          } catch (e) {
              console.error('Search failed:', e);
          }
      }
      
      displayResults(data) {
          let html = '';
          
          // Tasks section
          if (data.data.tasks.length) {
              html += '<div class="search-section">';
              html += '<h4>Tasks</h4>';
              data.data.tasks.forEach((task, index) => {
                  html += `<a href="/tasks/${task.id}" 
                              class="search-result" 
                              data-index="${index}">
                      <span class="title">${task.title}</span>
                      <span class="project">${task.project?.name || ''}</span>
                  </a>`;
              });
              html += '</div>';
          }
          
          // Projects section
          if (data.data.projects.length) {
              html += '<div class="search-section">';
              html += '<h4>Projects</h4>';
              data.data.projects.forEach((project, index) => {
                  html += `<a href="/projects/${project.id}" 
                              class="search-result"
                              data-index="${data.data.tasks.length + index}">
                      <span class="name">${project.name}</span>
                  </a>`;
              });
              html += '</div>';
          }
          
          if (!html) {
              html = '<div class="no-results">No results found</div>';
          }
          
          this.resultsContainer.innerHTML = html;
          this.showResults();
          this.selectedIndex = -1;
      }
      
      showResults() {
          this.resultsContainer.classList.remove('hidden');
      }
      
      hideResults() {
          this.resultsContainer.classList.add('hidden');
          this.resultsContainer.innerHTML = '';
          this.selectedIndex = -1;
      }
      
      handleKeydown(e) {
          const results = this.resultsContainer.querySelectorAll('.search-result');
          
          switch(e.key) {
              case 'ArrowDown':
                  e.preventDefault();
                  this.selectedIndex = Math.min(this.selectedIndex + 1, results.length - 1);
                  this.highlightResult(results);
                  break;
              case 'ArrowUp':
                  e.preventDefault();
                  this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
                  this.highlightResult(results);
                  break;
              case 'Enter':
                  if (this.selectedIndex >= 0 && results[this.selectedIndex]) {
                      results[this.selectedIndex].click();
                  }
                  break;
              case 'Escape':
                  this.hideResults();
                  this.searchInput.blur();
                  break;
          }
      }
      
      highlightResult(results) {
          results.forEach((r, i) => {
              r.classList.toggle('selected', i === this.selectedIndex);
          });
      }
      
      handleClickOutside(e) {
          if (!this.searchInput.contains(e.target) && 
              !this.resultsContainer.contains(e.target)) {
              this.hideResults();
          }
      }
      
      isInputFocused() {
          const active = document.activeElement;
          return active.tagName === 'INPUT' || 
                 active.tagName === 'TEXTAREA' ||
                 active.isContentEditable;
      }
  }
  
  // Initialize
  const searchManager = new SearchManager();
  ```

- [ ] **7.5.3** Add keyboard navigation (included above)

- [ ] **7.5.4** Style search UI
  ```css
  /* assets/css/search.css */
  
  .search-container {
      position: relative;
  }
  
  .search-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      max-height: 400px;
      overflow-y: auto;
      z-index: 1000;
  }
  
  .search-dropdown.hidden {
      display: none;
  }
  
  .search-section h4 {
      padding: 8px 12px;
      margin: 0;
      background: #f5f5f5;
      font-size: 12px;
      text-transform: uppercase;
      color: #666;
  }
  
  .search-result {
      display: flex;
      justify-content: space-between;
      padding: 10px 12px;
      text-decoration: none;
      color: #333;
      border-bottom: 1px solid #eee;
  }
  
  .search-result:hover,
  .search-result.selected {
      background: #f0f7ff;
  }
  
  .search-result .title {
      flex: 1;
  }
  
  .search-result .title mark {
      background: #fff3cd;
      padding: 0 2px;
  }
  
  .search-result .project {
      color: #666;
      font-size: 12px;
  }
  
  .no-results {
      padding: 20px;
      text-align: center;
      color: #666;
  }
  ```

### Completion Criteria
- [ ] Search input in header
- [ ] Debounced API calls (300ms)
- [ ] Results dropdown displays
- [ ] hideResults() function defined
- [ ] Keyboard navigation works (arrows, enter, escape)
- [ ] / shortcut focuses search

### Files to Create
```
templates/components/search-input.html.twig
assets/js/search.js
assets/css/search.css
```

---

## Sub-Phase 7.6: Undo System Implementation

### Objective
Complete the undo system with Redis storage and undo endpoint.

### Tasks

- [ ] **7.6.1** Finalize UndoService
  ```php
  // src/Service/UndoService.php
  
  class UndoService
  {
      private const TTL = 60; // seconds
      private const KEY_PREFIX = 'undo:';
      
      public function createToken(
          string $operation,
          int $userId,
          array $previousState,
          ?array $additionalData = null
      ): UndoToken {
          $token = 'undo_' . bin2hex(random_bytes(16));
          
          $data = [
              'operation' => $operation,
              'user_id' => $userId,
              'previous_state' => $previousState,
              'additional_data' => $additionalData,
              'created_at' => (new DateTimeImmutable())->format('c')
          ];
          
          $this->redis->setex(
              self::KEY_PREFIX . $token,
              self::TTL,
              json_encode($data)
          );
          
          return new UndoToken(
              $token,
              (new DateTimeImmutable())->add(new DateInterval('PT60S'))
          );
      }
  }
  ```

- [ ] **7.6.2** Implement undo operations
  ```php
  public function executeUndo(string $token, int $userId): UndoResult
  {
      $data = $this->getToken($token);
      
      if (!$data) {
          throw new NotFoundException('Undo token expired or invalid');
      }
      
      if ($data['user_id'] !== $userId) {
          throw new ForbiddenException('Token belongs to different user');
      }
      
      // Execute undo based on operation type
      $result = match($data['operation']) {
          'task_complete' => $this->undoTaskComplete($data),
          'task_delete' => $this->undoTaskDelete($data),
          'task_update' => $this->undoTaskUpdate($data),
          'batch' => $this->undoBatch($data),
          'project_archive' => $this->undoProjectArchive($data),
          default => throw new UnsupportedOperationException()
      };
      
      // Delete token after use
      $this->redis->del(self::KEY_PREFIX . $token);
      
      return $result;
  }
  ```

- [ ] **7.6.3** Implement specific undo handlers with full documentation
  ```php
  private function undoTaskComplete(array $data): UndoResult
  {
      $task = $this->taskRepository->find($data['previous_state']['id']);
      
      if (!$task) {
          throw new NotFoundException('Task no longer exists');
      }
      
      $task->setStatus($data['previous_state']['status']);
      $task->setCompletedAt(null);
      
      // RECURRING TASK HANDLING:
      // If this was a recurring task, delete the next task that was auto-created.
      // 
      // SAFETY CHECK: If the next task has been modified by the user after
      // creation (title changed, description added, etc.), we should still
      // delete it - the undo is undoing the completion action which created it.
      // 
      // Only skip deletion if the next task was itself completed or deleted.
      if (isset($data['additional_data']['next_task_id'])) {
          $nextTask = $this->taskRepository->find($data['additional_data']['next_task_id']);
          if ($nextTask && $nextTask->getStatus() !== 'completed') {
              $this->entityManager->remove($nextTask);
          }
      }
      
      return new UndoResult('task_complete', $task);
  }
  
  /**
   * UNDO TASK UPDATE
   * 
   * Restores the following fields from previous_state:
   * - title, description, status, project_id, priority
   * - due_date, due_time
   * - tags (re-associates tag entities)
   * - is_recurring, recurrence_rule, recurrence_type, recurrence_end_date
   * 
   * NOT restored (auto-regenerated):
   * - search_vector (regenerated by database trigger)
   * - updated_at (set automatically on save)
   */
  private function undoTaskUpdate(array $data): UndoResult
  {
      $task = $this->taskRepository->find($data['previous_state']['id']);
      
      if (!$task) {
          throw new NotFoundException('Task no longer exists');
      }
      
      $prev = $data['previous_state'];
      
      // Restore all editable fields
      $task->setTitle($prev['title']);
      $task->setDescription($prev['description'] ?? null);
      $task->setStatus($prev['status']);
      $task->setPriority($prev['priority']);
      $task->setDueDate($prev['due_date'] ? new DateTimeImmutable($prev['due_date']) : null);
      $task->setDueTime($prev['due_time'] ?? null);
      
      // Restore project association
      if ($prev['project_id']) {
          $project = $this->projectRepository->find($prev['project_id']);
          $task->setProject($project);
      } else {
          $task->setProject(null);
      }
      
      // Restore tags
      $task->clearTags();
      if (!empty($prev['tags'])) {
          foreach ($prev['tags'] as $tagId) {
              $tag = $this->tagRepository->find($tagId);
              if ($tag) {
                  $task->addTag($tag);
              }
          }
      }
      
      // Restore recurrence fields
      $task->setIsRecurring($prev['is_recurring'] ?? false);
      $task->setRecurrenceRule($prev['recurrence_rule'] ?? null);
      $task->setRecurrenceType($prev['recurrence_type'] ?? null);
      
      // search_vector will be regenerated by trigger
      
      return new UndoResult('task_update', $task);
  }
  
  /**
   * UNDO TASK DELETE
   * 
   * IMPORTANT: Restoring a deleted task with its original ID requires special handling.
   * Doctrine's identity map expects new entities to have null IDs.
   * 
   * Options for implementation:
   * 1. Use native SQL INSERT to restore with original ID
   * 2. Create entity with generated ID (loses original ID)
   * 3. Use Doctrine metadata to allow manual ID assignment
   * 
   * Recommended: Option 1 (native SQL) for full restoration.
   */
  private function undoTaskDelete(array $data): UndoResult
  {
      $prev = $data['previous_state'];
      
      // Use native SQL to restore with original ID
      // This avoids Doctrine identity map conflicts
      $sql = "
          INSERT INTO tasks (
              id, user_id, title, description, status, priority,
              due_date, due_time, project_id, position,
              is_recurring, recurrence_rule, recurrence_type,
              original_task_id, created_at, updated_at
          ) VALUES (
              :id, :userId, :title, :description, :status, :priority,
              :dueDate, :dueTime, :projectId, :position,
              :isRecurring, :recurrenceRule, :recurrenceType,
              :originalTaskId, :createdAt, NOW()
          )
      ";
      
      $this->entityManager->getConnection()->executeStatement($sql, [
          'id' => $prev['id'],
          'userId' => $prev['user_id'],
          'title' => $prev['title'],
          'description' => $prev['description'],
          'status' => $prev['status'],
          'priority' => $prev['priority'],
          'dueDate' => $prev['due_date'],
          'dueTime' => $prev['due_time'],
          'projectId' => $prev['project_id'],
          'position' => $prev['position'] ?? 0,
          'isRecurring' => $prev['is_recurring'] ?? false,
          'recurrenceRule' => $prev['recurrence_rule'],
          'recurrenceType' => $prev['recurrence_type'],
          'originalTaskId' => $prev['original_task_id'],
          'createdAt' => $prev['created_at'],
      ]);
      
      // Restore tag associations
      if (!empty($prev['tags'])) {
          foreach ($prev['tags'] as $tagId) {
              $this->entityManager->getConnection()->executeStatement(
                  "INSERT INTO task_tags (task_id, tag_id) VALUES (:taskId, :tagId)",
                  ['taskId' => $prev['id'], 'tagId' => $tagId]
              );
          }
      }
      
      // Clear entity manager to refresh state
      $this->entityManager->clear();
      
      // Fetch the restored task
      $task = $this->taskRepository->find($prev['id']);
      
      return new UndoResult('task_delete', $task);
  }
  ```

- [ ] **7.6.4** Create undo endpoint
  ```php
  // src/Controller/Api/UndoController.php
  
  POST /api/v1/undo
  {
    "undo_token": "undo_abc123xyz"
  }
  
  Response (success):
  {
    "data": {
      "operation": "task_complete",
      "restored": {
        "id": 123,
        "status": "pending",
        ...
      }
    },
    "message": "Task completion undone"
  }
  
  Response (expired):
  {
    "error": {
      "code": "UNDO_EXPIRED",
      "message": "Undo token has expired"
    }
  }
  ```

- [ ] **7.6.5** Store undo tokens for all undoable operations
  ```php
  // TaskService.php - ensure undo tokens created for:
  // - updateStatus() (especially completion)
  // - delete()
  // - update() (store previous state per fields documented above)
  
  // ProjectService.php - ensure undo tokens for:
  // - archive()
  
  // BatchOperationService.php - ensure single undo for batch
  
  /**
   * Example: Creating undo token for task update
   */
  public function update(Task $task, array $data): TaskUpdateResult
  {
      // Capture previous state BEFORE making changes
      $previousState = [
          'id' => $task->getId(),
          'title' => $task->getTitle(),
          'description' => $task->getDescription(),
          'status' => $task->getStatus(),
          'priority' => $task->getPriority(),
          'project_id' => $task->getProject()?->getId(),
          'due_date' => $task->getDueDate()?->format('c'),
          'due_time' => $task->getDueTime(),
          'tags' => $task->getTags()->map(fn($t) => $t->getId())->toArray(),
          'is_recurring' => $task->isRecurring(),
          'recurrence_rule' => $task->getRecurrenceRule(),
          'recurrence_type' => $task->getRecurrenceType(),
      ];
      
      // Apply changes...
      
      // Create undo token
      $undoToken = $this->undoService->createToken(
          'task_update',
          $task->getUser()->getId(),
          $previousState
      );
      
      return new TaskUpdateResult($task, $undoToken);
  }
  ```

### Completion Criteria
- [ ] Undo tokens stored in Redis
- [ ] 60 second TTL enforced
- [ ] Undo endpoint works
- [ ] All undoable operations return token
- [ ] Token validated against user
- [ ] Task delete restore uses native SQL for ID preservation
- [ ] Task update restores all documented fields
- [ ] Recurring task undo handles next task correctly

### Files to Create/Update
```
src/Service/UndoService.php (updated)
src/Controller/Api/UndoController.php (new)
src/DTO/UndoResult.php (new)
```

---

## Sub-Phase 7.7: Undo UI Integration

### Objective
Create the frontend undo toast notifications.

### Tasks

- [ ] **7.7.1** Create toast notification component
  ```javascript
  // assets/js/toast.js
  
  class ToastManager {
      show(message, options = {}) {
          const toast = document.createElement('div');
          toast.className = 'toast';
          toast.innerHTML = `
              <span class="message">${message}</span>
              ${options.undoToken ? `
                  <button class="undo-btn" data-token="${options.undoToken}">
                      Undo (${options.countdown || 5}s)
                  </button>
              ` : ''}
              <button class="close-btn">×</button>
          `;
          
          document.body.appendChild(toast);
          
          // Close button handler
          toast.querySelector('.close-btn').addEventListener('click', () => {
              this.hide(toast);
          });
          
          if (options.undoToken) {
              this.startCountdown(toast, options.undoToken);
          }
          
          setTimeout(() => this.hide(toast), options.duration || 5000);
      }
      
      hide(toast) {
          toast.classList.add('hiding');
          setTimeout(() => toast.remove(), 300);
      }
      
      showSuccess(message) {
          this.show(message, { duration: 3000 });
      }
      
      showError(message) {
          const toast = document.createElement('div');
          toast.className = 'toast toast-error';
          toast.innerHTML = `<span class="message">${message}</span>`;
          document.body.appendChild(toast);
          setTimeout(() => this.hide(toast), 5000);
      }
  }
  ```

- [ ] **7.7.2** Implement countdown timer
  ```javascript
  startCountdown(toast, token) {
      let seconds = 5;
      const btn = toast.querySelector('.undo-btn');
      
      const interval = setInterval(() => {
          seconds--;
          btn.textContent = `Undo (${seconds}s)`;
          
          if (seconds <= 0) {
              clearInterval(interval);
              btn.disabled = true;
              btn.textContent = 'Expired';
          }
      }, 1000);
      
      btn.addEventListener('click', async () => {
          clearInterval(interval);
          btn.disabled = true;
          btn.textContent = 'Undoing...';
          await this.executeUndo(token);
          this.hide(toast);
      });
  }
  ```

- [ ] **7.7.3** Execute undo from UI
  ```javascript
  async executeUndo(token) {
      try {
          const response = await fetch('/api/v1/undo', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${getToken()}`
              },
              body: JSON.stringify({ undo_token: token })
          });
          
          if (response.ok) {
              // Refresh relevant part of UI
              this.showSuccess('Action undone');
              window.location.reload(); // Or smart refresh
          } else {
              const error = await response.json();
              this.showError(error.error.message);
          }
      } catch (e) {
          this.showError('Failed to undo');
      }
  }
  ```

- [ ] **7.7.4** Integrate with task actions
  ```javascript
  // On task completion
  async function completeTask(taskId) {
      const response = await fetch(`/api/v1/tasks/${taskId}/status`, {
          method: 'PATCH',
          headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${getToken()}`
          },
          body: JSON.stringify({ status: 'completed' })
      });
      
      const data = await response.json();
      
      if (data.undo_token) {
          toastManager.show('Task completed', {
              undoToken: data.undo_token,
              duration: 10000  // 10 seconds visible
          });
      }
      
      // Update UI
      refreshTaskList();
  }
  ```

- [ ] **7.7.5** Style toast notifications
  ```css
  .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
      animation: slideUp 0.3s ease;
  }
  
  .toast.hiding {
      animation: slideDown 0.3s ease forwards;
  }
  
  .toast-error {
      background: #dc3545;
  }
  
  .toast .undo-btn {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
  }
  
  .toast .undo-btn:disabled {
      background: #666;
      cursor: not-allowed;
  }
  
  .toast .close-btn {
      background: none;
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      padding: 0 5px;
  }
  
  @keyframes slideUp {
      from { transform: translateX(-50%) translateY(100%); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
  }
  
  @keyframes slideDown {
      from { transform: translateX(-50%) translateY(0); opacity: 1; }
      to { transform: translateX(-50%) translateY(100%); opacity: 0; }
  }
  ```

### Completion Criteria
- [ ] Toast appears on undoable actions
- [ ] Countdown timer displays
- [ ] Undo button functional
- [ ] UI updates after undo
- [ ] Toast dismissable
- [ ] Error toast for failures

### Files to Create
```
assets/js/toast.js
assets/css/toast.css
```

---

## Sub-Phase 7.8: Search & Undo Tests

### Objective
Comprehensive tests for search and undo functionality.

### Tasks

- [ ] **7.8.1** Search tests
  ```php
  // tests/Functional/Api/SearchApiTest.php
  
  // Basic search
  - testSearchReturnsMatchingTasks()
  - testSearchRanksResultsByRelevance()
  - testSearchHighlightsMatches()
  - testSearchWithFilters()
  - testSearchFiltersApplyAfterFTS()  // Verify FTS-first behavior
  - testSearchEmptyQuery()
  - testSearchQueryTooShort()
  - testSearchNoResults()
  - testSearchIncludesProjects()
  - testSearchPerformance()  // <100ms
  
  // Prefix search / autocomplete
  - testPrefixSearchTaskTitles()
  - testPrefixSearchProjectNames()
  - testPrefixSearchTagNames()
  - testPrefixSearchMinLength()
  
  // Advanced search (if implemented)
  - testPhraseSearch()  // "meeting notes"
  - testPrefixTokenSearch()  // meet*
  - testNegationSearch()  // -cancelled
  ```

- [ ] **7.8.2** Undo tests
  ```php
  // tests/Functional/Api/UndoApiTest.php
  
  // Basic undo operations
  - testUndoTaskCompletion()
  - testUndoRecurringTaskCompletion()
  - testUndoRecurringTaskCompletionDeletesNextTask()
  - testUndoRecurringTaskWhenNextTaskModified()  // Still deletes
  - testUndoRecurringTaskWhenNextTaskCompleted()  // Does not delete
  - testUndoTaskDeletion()
  - testUndoTaskDeletionRestoresOriginalId()
  - testUndoTaskDeletionRestoresTags()
  - testUndoTaskUpdate()
  - testUndoTaskUpdateRestoresAllFields()
  - testUndoBatchOperation()
  - testUndoProjectArchive()
  
  // Error cases
  - testUndoExpiredToken()
  - testUndoInvalidToken()
  - testUndoWrongUser()
  - testUndoAlreadyUsedToken()
  ```

- [ ] **7.8.3** Redis integration tests
  ```php
  // tests/Integration/RedisUndoTest.php
  
  - testTokenStoredInRedis()
  - testTokenExpires()
  - testTokenDeletedAfterUse()
  - testTokenContainsCorrectData()
  ```

- [ ] **7.8.4** Search UI tests (optional)
  ```javascript
  // tests/js/search.test.js (if using Jest)
  
  - testDebounceWaits300ms()
  - testMinQueryLength()
  - testKeyboardNavigation()
  - testEscapeClosesResults()
  - testSlashFocusesSearch()
  ```

### Completion Criteria
- [ ] Search functionality tested (including prefix search)
- [ ] FTS-first filter combination tested
- [ ] All undo operations tested
- [ ] Undo previous state fields tested
- [ ] Recurring task undo edge cases tested
- [ ] Redis integration verified
- [ ] Edge cases covered

### Files to Create
```
tests/Functional/Api/SearchApiTest.php
tests/Functional/Api/UndoApiTest.php
tests/Integration/RedisUndoTest.php
```

---

## Phase 7 Deliverables Checklist

At the end of Phase 7, the following should be complete:

### Search
- [ ] Full-text search index created (GIN)
- [ ] Search returns ranked results
- [ ] Search highlights matches
- [ ] Search combines with filters (FTS-first approach)
- [ ] Uses PostgreSQL @@ operator (not MySQL MATCH AGAINST)
- [ ] Prefix search for autocomplete (tasks, projects, tags)
- [ ] ResultSetMapping properly defined
- [ ] Search UI with dropdown
- [ ] hideResults() function defined
- [ ] Keyboard navigation for search
- [ ] Performance < 100ms

### Undo System
- [ ] Undo tokens stored in Redis
- [ ] 60 second TTL enforced
- [ ] Undo endpoint functional
- [ ] All undoable operations return tokens
- [ ] Token validated against user
- [ ] Previous state fields documented and complete
- [ ] Task delete uses native SQL for ID restoration
- [ ] Recurring task undo handles modified next task

### UI
- [ ] Toast notifications with countdown
- [ ] Undo button functional in UI
- [ ] Error handling for expired/invalid tokens

### Testing
- [ ] Comprehensive tests passing
- [ ] Prefix search tests included
- [ ] Undo field restoration tests included
